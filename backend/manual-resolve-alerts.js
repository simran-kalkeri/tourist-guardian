// Manual script to resolve alerts by updating the backend's internal state
const fetch = require('node-fetch');

async function manualResolveAlerts() {
  try {\n    console.log('\ud83d\udd27 Manually resolving stale alerts...');\n    \n    // Since the database approach isn't working, let's use a different strategy:\n    // We'll add the stale tourist zones to the memory tracking, then trigger exit\n    \n    console.log('1ï¸âƒ£ Getting current critical alerts...');\n    const alertsResponse = await fetch('http://localhost:5000/api/geofencing/critical-alerts');\n    const alertsData = await alertsResponse.json();\n    const alerts = alertsData.alerts || [];\n    \n    if (alerts.length === 0) {\n      console.log('âœ… No alerts to resolve!');\n      return;\n    }\n    \n    console.log(`ðŸ“Š Found ${alerts.length} alert(s) to resolve:`);\n    alerts.forEach((alert, i) => {\n      console.log(`   ${i+1}. ${alert.touristName} (ID: ${alert.touristId}) - entered ${alert.timestamp}`);\n    });\n    \n    // For each alert, we'll simulate being in a high-risk zone first, then exiting\n    for (let i = 0; i < alerts.length; i++) {\n      const alert = alerts[i];\n      console.log(`\\n\ud83d\udd04 Processing alert ${i+1}/${alerts.length}: ${alert.touristName}`);\n      \n      // Step 1: Put the tourist in a known high-risk zone to establish tracking\n      console.log('   \ud83d\udccd Step 1: Simulating entry to high-risk zone (to establish tracking)...');\n      \n      const highRiskLocation = {\n        touristId: alert.touristId,\n        latitude: 28.6562, // Delhi Red Fort - known high-risk zone\n        longitude: 77.2410,\n        touristName: alert.touristName\n      };\n      \n      const enterResponse = await fetch('http://localhost:5000/api/geofencing/check-location', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(highRiskLocation)\n      });\n      \n      if (enterResponse.ok) {\n        const enterResult = await enterResponse.json();\n        console.log(`   \u2705 Enter result: ${enterResult.message}`);\n        console.log(`   \ud83d\udcca Zones entered: ${enterResult.data?.enteredZones || 0}`);\n      }\n      \n      // Small delay\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Step 2: Now move to zone-free area (this should trigger exit)\n      console.log('   \ud83c\udfc3 Step 2: Moving to zone-free area (to trigger exit)...');\n      \n      const safeLocation = {\n        touristId: alert.touristId,\n        latitude: 25.0000, // Zone-free area\n        longitude: 90.0000,\n        touristName: alert.touristName\n      };\n      \n      const exitResponse = await fetch('http://localhost:5000/api/geofencing/check-location', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(safeLocation)\n      });\n      \n      if (exitResponse.ok) {\n        const exitResult = await exitResponse.json();\n        console.log(`   \u2705 Exit result: ${exitResult.message}`);\n        console.log(`   \ud83d\udcca Zones exited: ${exitResult.data?.exitedZones || 0}`);\n        \n        if (exitResult.data?.exitedZones > 0) {\n          console.log(`   \ud83c\udf89 SUCCESS! Tourist ${alert.touristName} exited zone(s)`);\n        } else {\n          console.log(`   \u26a0\ufe0f  No exit detected for ${alert.touristName}`);\n        }\n      }\n      \n      // Delay between tourists\n      await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n    \n    // Final verification\n    console.log('\\n\u23f3 Waiting for final database updates...');\n    await new Promise(resolve => setTimeout(resolve, 5000));\n    \n    console.log('\\n\ud83d\udd0d Final verification...');\n    const finalResponse = await fetch('http://localhost:5000/api/geofencing/critical-alerts');\n    const finalData = await finalResponse.json();\n    const finalAlerts = finalData.alerts || [];\n    \n    console.log(`\ud83d\udcca Final result: ${finalAlerts.length} critical alerts remaining`);\n    \n    if (finalAlerts.length === 0) {\n      console.log('\\n\ud83c\udf89 PERFECT! All critical alerts have been resolved!');\n      console.log('\u2705 Your frontend should now show 0 critical alerts.');\n    } else {\n      console.log('\\n\u26a0\ufe0f  Some alerts still remain:');\n      finalAlerts.forEach((alert, i) => {\n        console.log(`   ${i+1}. ${alert.touristName} (${alert.timestamp})`);\n      });\n      \n      console.log('\\n\ud83d\udca1 If alerts persist, it suggests a deeper database issue.');\n      console.log('Alternative: Clear all alerts via admin panel or database reset.');\n    }\n    \n  } catch (error) {\n    console.error('\u274c Manual resolution failed:', error.message);\n    console.log('\\n\ud83d\udca1 Last resort: You may need to manually delete the alert records from MongoDB.');\n  }\n}\n\nmanualResolveAlerts();"}